name: Test Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Install uv
      run: |
        curl -LsSf https://astral.sh/uv/install.sh | sh
        echo "$HOME/.cargo/bin" >> $GITHUB_PATH
        
    - name: Install dependencies
      run: make install
        
    - name: Clone private repository with migrations
      uses: actions/checkout@v4
      with:
        repository: ${{ secrets.MIGRATIONS_REPO }}
        ssh-key: ${{ secrets.DEPLOY_KEY }} 
        path: migrations
        fetch-depth: 1
        ref: main

    - name: Create .env for Docker Compose
      run: |
        cat > .env <<EOF
        WEB_SERVER_PORT=${{ secrets.WEB_SERVER_PORT }}
        REDIS_PORT=${{ secrets.REDIS_PORT }}
        RABBITMQ_PORT=${{ secrets.RABBITMQ_PORT }}
        RABBITMQ_PORT_WEB=${{ secrets.RABBITMQ_PORT_WEB }}
        RABBITMQ_USER=${{ secrets.RABBITMQ_USER }}
        RABBITMQ_PASSWORD=${{ secrets.RABBITMQ_PASSWORD }}
        POSTGRES_DB=${{ secrets.POSTGRES_DB }}
        POSTGRES_USER=${{ secrets.POSTGRES_USER }}
        POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
        POSTGRES_PORT=${{ secrets.POSTGRES_PORT }}
        EOF
        chmod 600 .env

    - name: Create server config from secret
      run: |
        mkdir -p config
        echo '${{ secrets.SERVER_CONFIG }}' > config/server.yaml
        chmod 600 config/server.yaml
            
    - name: Start test containers
      env:
        WEB_SERVER_PORT: ${{ secrets.WEB_SERVER_PORT }}
        REDIS_PORT: ${{ secrets.REDIS_PORT }}
        RABBITMQ_PORT: ${{ secrets.RABBITMQ_PORT }}
        RABBITMQ_PORT_WEB: ${{ secrets.RABBITMQ_PORT_WEB }}
        RABBITMQ_USER: ${{ secrets.RABBITMQ_USER }}
        RABBITMQ_PASSWORD: ${{ secrets.RABBITMQ_PASSWORD }}
        POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
        POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
        POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        POSTGRES_PORT: ${{ secrets.POSTGRES_PORT }}
      run: make start-containers
      
    - name: Wait for services to be ready
      env:
        POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
        POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
        WEB_SERVER_PORT: ${{ secrets.WEB_SERVER_PORT }}
      run: |
        echo "üîç Checking service status..."

        echo "containers status:"
        docker compose ps
        
        # Check PostgreSQL
        echo "üìä Waiting for PostgreSQL..."
        if timeout 60 bash -c 'until docker compose exec -T postgres pg_isready -U $POSTGRES_USER -d $POSTGRES_DB; do sleep 2; done'; then
          echo "‚úÖ PostgreSQL is ready"
        else
          echo "‚ùå PostgreSQL failed to start or is not responding"
          echo "üìã PostgreSQL container status:"
          docker compose ps postgres
          echo "üìã PostgreSQL logs:"
          docker compose logs postgres
          exit 1
        fi
        
        # Check Redis
        echo "üìä Waiting for Redis..."
        if timeout 60 bash -c 'until docker compose exec -T redis redis-cli ping; do sleep 2; done'; then
          echo "‚úÖ Redis is ready"
        else
          echo "‚ùå Redis failed to start or is not responding"
          echo "üìã Redis container status:"
          docker compose ps redis
          echo "üìã Redis logs:"
          docker compose logs redis
          exit 1
        fi
        
        # Check RabbitMQ
        echo "üìä Waiting for RabbitMQ..."
        if timeout 60 bash -c 'until docker compose exec -T rabbitmq rabbitmq-diagnostics -q ping; do sleep 2; done'; then
          echo "‚úÖ RabbitMQ is ready"
        else
          echo "‚ùå RabbitMQ failed to start or is not responding"
          echo "üìã RabbitMQ container status:"
          docker compose ps rabbitmq
          echo "üìã RabbitMQ logs:"
          docker compose logs rabbitmq
          exit 1
        fi
        
        # Check webserver (if it's running)
        echo "üìä Waiting for webserver..."
        if timeout 60 bash -c 'until curl -f http://localhost:${WEB_SERVER_PORT}/api/v0/health; do sleep 2; done'; then
          echo "‚úÖ Webserver is ready"
        else
          echo "‚ùå Webserver failed to start or is not responding"
          echo "üìã Webserver container status:"
          docker compose ps webserver
          echo "üìã Webserver logs:"
          docker compose logs webserver
          echo "üìã All containers status:"
          docker compose ps
          exit 1
        fi
        
        echo "üéâ All services are ready!"
        
    - name: Install migrate utility
      run: |
        curl -L https://github.com/golang-migrate/migrate/releases/latest/download/migrate.linux-amd64.tar.gz | tar xvz
        sudo mv migrate /usr/local/bin/
        migrate -version
        
    - name: Apply database migrations
      env:
        POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
        POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
        POSTGRES_HOST: localhost
        POSTGRES_PORT: ${{ secrets.POSTGRES_PORT }}
        MIGRATIONS_PATH: ${{ secrets.MIGRATIONS_PATH }}
      run: |
        if [ -d "migrations" ]; then
          echo "üîç Checking migrations directory structure..."
          echo "üìÅ Contents of migrations directory:"
          ls -la migrations/
          
          if [ -d "$MIGRATIONS_PATH" ]; then
            echo "üìÅ Contents of $MIGRATIONS_PATH:"
            ls -la "$MIGRATIONS_PATH"
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ up –º–∏–≥—Ä–∞—Ü–∏–π
            up_files=$(find "$MIGRATIONS_PATH" -name "*.up.sql" | wc -l)
            if [ "$up_files" -eq 0 ]; then
              echo "‚ùå No .up.sql files found in $MIGRATIONS_PATH"
              echo "üìÅ Available files:"
              ls -la "$MIGRATIONS_PATH"
              exit 1
            fi
            
            echo "üîÑ Found $up_files up migration files"
            echo "üîÑ Applying migrations using migrate utility..."
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Ç—Ä–æ–∫—É –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ PostgreSQL
            DATABASE_URL="postgres://$POSTGRES_USER:$POSTGRES_PASSWORD@$POSTGRES_HOST:$POSTGRES_PORT/$POSTGRES_DB?sslmode=disable"
            
            # –ü—Ä–∏–º–µ–Ω—è–µ–º –º–∏–≥—Ä–∞—Ü–∏–∏
            migrate -path "$MIGRATIONS_PATH" -database "$DATABASE_URL" up
            
            if [ $? -eq 0 ]; then
              echo "üéâ All migrations applied successfully!"
              echo "üìä Migration status:"
              migrate -path "$MIGRATIONS_PATH" -database "$DATABASE_URL" version
            else
              echo "‚ùå Failed to apply migrations"
              exit 1
            fi
          else
            echo "‚ùå Migration directory $MIGRATIONS_PATH not found"
            echo "üìÅ Available directories in migrations:"
            find migrations -type d
            exit 1
          fi
        else
          echo "‚ùå No migrations directory found"
          exit 1
        fi
      
    - name: Stop containers
      if: always()
      run: make stop-containers
